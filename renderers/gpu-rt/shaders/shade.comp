#version 450
#extension GL_GOOGLE_include_directive : require

#include "structs.glsl"
#include "utils.glsl"
#include "random.glsl"

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba32f) uniform writeonly image2D OutputTex;
layout(std430, set = 0, binding = 1) buffer Camera { CameraView camera; };
layout(std430, set = 0, binding = 2) buffer pathStates { vec4 states[]; };
layout(std430, set = 0, binding = 3) buffer pathOrigins { vec4 origins[]; };
layout(std430, set = 0, binding = 4) buffer pathDirections { vec4 directions[]; };
layout(std430, set = 0, binding = 5) buffer pathThroughputs { vec4 throughputs[]; };
layout(std430, set = 0, binding = 6) buffer accBuffer { vec4 acPixels[]; };

layout(std430, set = 1, binding = 0) buffer readonly primIndices { uint prim_indices[]; };
layout(std430, set = 1, binding = 1) buffer readonly meshBVHNodes { BVHNode bvh_nodes[]; };
layout(std430, set = 1, binding = 2) buffer readonly meshMBVHNodes { MBVHNode mbvh_nodes[]; };
layout(std140, set = 1, binding = 3) buffer readonly meshTriangles { RTTriangle rt_triangles[]; };

layout(std430, set = 2, binding = 0) buffer readonly instanceDescriptors { InstanceDescriptor instances[]; };
layout(std430, set = 2, binding = 1) buffer readonly topIndices { uint instance_indices[]; };
layout(std430, set = 2, binding = 2) buffer readonly topBVHNodes { BVHNode top_bvh_nodes[]; };
layout(std430, set = 2, binding = 3) buffer readonly topMBVHNodes { MBVHNode top_mbvh_nodes[]; };
layout(std430, set = 2, binding = 4) buffer readonly Materials { Material materials[]; };
layout(set = 2, binding = 5) uniform texture2DArray matTextures;
layout(set = 2, binding = 6) uniform sampler matTexSampler;

layout(std430, set = 3, binding = 0) buffer readonly PointLights { PointLight pointLights; };
layout(std430, set = 3, binding = 1) buffer readonly SpotLights { SpotLight spotLights; };
layout(std430, set = 3, binding = 2) buffer readonly AreaLights { AreaLight areaLights; };
layout(std430, set = 3, binding = 3) buffer readonly DirectionalLights { DirectionalLight directionalLights; };

#define MIPLEVELCOUNT 5

#define PATH_ID floatBitsToInt(O.w)
#define INST_ID floatBitsToInt(S.x)
#define TRI_ID floatBitsToInt(S.y)
#define T_VAL S.z
#define HIT_U (float(floatBitsToUint(S.w) & 65535) * (1.0f / 65535.0f))
#define HIT_V (float(floatBitsToUint(S.w) >> 16) * (1.0f / 65535.0f))
#define MAT_ID rt_triangles[TRI_ID].mat_id

vec4 fetchTexel(const vec2 texCoord, const int texturdId, const float LOD);
vec4 fetchTexelTrilinear(const float lambda, const vec2 texCoord, const int textureId);

void main()
{
    uint job_id = gl_GlobalInvocationID.x;
    if (job_id >= camera.path_count) {
        return;
    }

    const uint offset = camera.width * camera.height;
    const uint shadeBufferIndex = camera.path_length % 2;
    const uint nextBufferIndex = 1 - shadeBufferIndex;

    job_id = job_id + shadeBufferIndex * offset;

    const vec4 S = states[job_id];
    const vec4 O = origins[job_id];
    vec3 throughput = camera.path_length == 0 ? vec3(1) : throughputs[job_id].xyz;

    if (INST_ID < 0) { // Did not hit anything
        return;
    }

    vec4 color = materials[MAT_ID].color;
    if (any(greaterThan(color.xyz, vec3(1.0f)))) { // Hit a light
        acPixels[PATH_ID] += vec4(color.xyz * throughput, 0);
        return;
    }

    const uint sampleId = PATH_ID / (offset) + camera.sample_count;
    uint seed = wang_hash(PATH_ID * 16789 + sampleId * 1791 + camera.path_length * 720898027);

    const vec4 D = directions[job_id];
    const uint flags = materials[MAT_ID].flags;
    const float u = HIT_U;
    const float v = HIT_V;
    const float w = 1.0 - u - v;

    vec3 gN = rt_triangles[TRI_ID].gn;
    vec3 N = w * rt_triangles[TRI_ID].n0 + u * rt_triangles[TRI_ID].n1 + v * rt_triangles[TRI_ID].n2;
    vec4 T = w * rt_triangles[TRI_ID].T0 + u * rt_triangles[TRI_ID].T1 + v * rt_triangles[TRI_ID].T2;

    gN = normalize((instances[INST_ID].normal * vec4(gN, 0.0)).xyz);
    N = normalize((instances[INST_ID].normal * vec4(N, 0.0)).xyz);
    T = vec4(normalize((instances[INST_ID].normal * vec4(T.xyz, 0.0)).xyz), T.w);
    const vec3 B = cross(N, T.xyz) * T.w;

    if (HAS_DIFFUSE_MAP(flags) || HAS_NORMMAL_MAP(flags) || HAS_ROUGHNESS_MAP(flags) || HAS_METALLIC_MAP(flags) || HAS_EMISSIVE_MAP(flags) || HAS_SHEEN_MAP(flags))
    {
        const float lambda = sqrt(rt_triangles[TRI_ID].lod) + log2(camera.spread_angle * (1.0 / abs(dot(D.xyz, N.xyz))));
        const float tu = w * rt_triangles[TRI_ID].tu0 + u * rt_triangles[TRI_ID].tu1 + v * rt_triangles[TRI_ID].tu2;
        const float tv = w * rt_triangles[TRI_ID].tv0 + u * rt_triangles[TRI_ID].tv1 + v * rt_triangles[TRI_ID].tv2;

        if (HAS_DIFFUSE_MAP(flags)) {
            color *= fetchTexelTrilinear(lambda, vec2(tu, tv), materials[MAT_ID].diffuse_map);
        }

        if (HAS_NORMMAL_MAP(flags)) {
            N = normalize(mat3(T.xyz, B.xyz, N.xyz) * ((fetchTexel(vec2(tu, tv), materials[MAT_ID].normal_map, int(lambda)).xyz - 0.5) * 2.0));
        }
    }

    const bool backFacing = dot(D.xyz, gN) >= 0.0f;
    if (backFacing) {
        N = N * -1.0f;
    }

    const vec3 P = O.xyz + T_VAL * D.xyz;
    const vec3 R = normalize(tangent_to_world(sample_hemisphere(randf(seed), randf(seed)), N.xyz, T.xyz, B.xyz));
    const vec3 bsdf = color.xyz * (1.0f / 3.14159265359f);

    const float n_dot_r = abs(dot(N, R));
    const float pdf = n_dot_r * (1.0f / 3.14159265359f);
    throughput = throughput * bsdf / pdf * n_dot_r / (2.0f * 3.14159265359f);
    if (any(lessThan(throughput, vec3(0.0f)))) {
        return;
    }

    // Prevent any nans
    throughput = max(throughput, vec3(0.0f));

    // Get compacted index for extension ray
    const int ext_id = atomicAdd(camera.extensionId, 1) + int(nextBufferIndex * offset);

    origins[ext_id] = vec4(P.xyz + R.xyz * 1e-4f, intBitsToFloat(PATH_ID));
    directions[ext_id] = vec4(R, D.w);
    throughputs[ext_id] = vec4(throughput, 0);
}

vec4 fetchTexel(const vec2 texCoord, const int textureId, const float LOD)
{
    return textureLod(sampler2DArray(matTextures, matTexSampler), vec3(texCoord, textureId), LOD).rgba;
}

vec4 fetchTexelTrilinear(const float lambda, const vec2 texCoord, const int textureId)
{
    const int level0 = min(MIPLEVELCOUNT - 1, int(lambda));
    const int level1 = min(MIPLEVELCOUNT - 1, level0 + 1);
    const float f = lambda - floor(lambda);
    const vec4 p0 = fetchTexel(texCoord, textureId, level0);
    const vec4 p1 = fetchTexel(texCoord, textureId, level1);
    return (1.0 - f) * p0 + f * p1;
}