#version 450
#extension GL_GOOGLE_include_directive : require

#include "structs.glsl"
#include "intersection.glsl"

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba32f) uniform writeonly image2D OutputTex;
layout(set = 0, binding = 1) uniform Camera {
    CameraView camera;
};
layout(std430, set = 0, binding = 2) buffer writeonly pathStates { vec4 states[]; };
layout(std430, set = 0, binding = 3) buffer writeonly pathOrigins { vec4 origins[]; };
layout(std430, set = 0, binding = 4) buffer writeonly pathDirections { vec4 directions[]; };

layout(std430, set = 1, binding = 0) buffer readonly instanceDescriptors { InstanceDescriptor instances[]; };
layout(std430, set = 1, binding = 1) buffer readonly primIndices { uint prim_indices[]; };
layout(std430, set = 1, binding = 2) buffer readonly meshBVHNodes { BVHNode bvh_nodes[]; };
//layout(std430, set = 1, binding = 3) buffer readonly meshMBVHNodes { MBVHNode bvh_nodes[]; };
layout(std430, set = 1, binding = 4) buffer readonly meshTriangles { RTTriangle rt_triangles[]; };

//layout(std430, set = 1, binding = 5) buffer readonly topIndices { uint instance_indices[]; };
//layout(std430, set = 1, binding = 6) buffer readonly topBVHNodes { BVHNode top_bvh_nodes[]; };
//layout(std430, set = 1, binding = 7) buffer readonly topMBVHNodes { MBVHNode top_bvh_nodes[]; };

void intersect_bvh(const vec3 origin, const vec3 direction, uint bvh_offset, uint triangle_offset, uint prim_offset, float t_min, inout float t)
{
    int hit_stack[64];
    int stack_ptr = 0;

    const vec3 dir_inverse = 1.0 / direction;
    while (stack_ptr >= 0) {
        int node_index = hit_stack[stack_ptr];
        stack_ptr -= 1;

        int count = bvh_nodes[bvh_offset + node_index].count;
        int left_first = bvh_nodes[bvh_offset + node_index].left_first;

        if (count >= 0) {
            for (int i = 0; i < count; i++)
            {
                uint prim_id = triangle_offset + prim_indices[left_first + i + prim_offset];
                intersect(rt_triangles[prim_id], origin, direction, t_min, t);
            }
        } else if (left_first >= 0) {
            float _ltmin, _ltmax;
            float _rtmin, _rtmax;
            bool hit_left = intersect_node(bvh_nodes[left_first + bvh_offset], origin, dir_inverse, t, _rtmin, _rtmax);
            bool hit_right = intersect_node(bvh_nodes[left_first + bvh_offset], origin, dir_inverse, t, _rtmin, _rtmax);
            if (hit_left && hit_right) {
                if (_ltmin < _rtmin) {
                    stack_ptr += 1;
                    hit_stack[stack_ptr] = left_first + 1;
                    stack_ptr += 1;
                    hit_stack[stack_ptr] = left_first;
                } else {
                    stack_ptr += 1;
                    hit_stack[stack_ptr] = left_first;
                    stack_ptr += 1;
                    hit_stack[stack_ptr] = left_first + 1;
                }
            } else if (hit_left) {
                stack_ptr += 1;
                hit_stack[stack_ptr] = left_first;
            } else if (hit_right) {
                stack_ptr += 1;
                hit_stack[stack_ptr] = left_first + 1;
            }
        }
    }
}


void main() {
    const ivec2 pixel_id = ivec2(gl_GlobalInvocationID.xy);
    const ivec2 size = imageSize(OutputTex);
    if (pixel_id.x >= size.x || pixel_id.y > size.y) {
        return;
    }

    const int path_id = pixel_id.x + pixel_id.y * size.x;

    const float u = pixel_id.x * camera.inv_width;
    const float v = pixel_id.y * camera.inv_height;

    const vec3 point_on_pixel = camera.p1.xyz + u * camera.right.xyz + v * camera.up.xyz;
    const vec3 direction = normalize(point_on_pixel - camera.position.xyz);

    origins[path_id] = vec4(camera.position.xyz, intBitsToFloat(path_id));
    directions[path_id] = vec4(direction, 0.0);

    vec3 color = vec3(0.0);

    float t = 1e26;
    const vec3 origin = camera.position.xyz;

//    if (intersect(rt_triangles[0], camera.position.xyz, direction, 1e-5, t)) {
//        color = abs(vec3(vec4(rt_triangles[0].gn_v0.xyz, 0)));
//    }
//
//    if (intersect(rt_triangles[1], camera.position.xyz, direction, 1e-5, t)) {
//        color = abs(vec3(vec4(rt_triangles[1].gn_v0.xyz, 0)));
//    }

    const vec3 inst_org = (instances[0].inverse * vec4(origin, 1)).xyz;
    const vec3 inst_dir = (instances[0].normal * vec4(direction, 0)).xyz;

    for (int i = 0; i < 32; i++) {
        if (intersect(rt_triangles[i], inst_org, inst_dir, 1e-5, t)) {
            color = abs(vec3(vec4(rt_triangles[i].gn.xyz, 0)));
        }
    }

//    intersect_bvh(origin, direction, 0, 0, 0, 1e-5, t);
//    if (t < 1e25) {
//        color = direction;
//    }

    imageStore(OutputTex, pixel_id, vec4(color, 1.0));
}