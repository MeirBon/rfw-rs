#version 450

#include "random.glsl"

layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform Locals {
    mat4 View;
    mat4 Proj;
    uvec4 light_count;
    vec4 cam_pos;
};

layout(set = 1, binding = 0, r16f) uniform writeonly image2D SSAOTexture;
layout(set = 1, binding = 1) uniform sampler Sampler;
layout(set = 1, binding = 2) uniform texture2D ScreenSpace;
layout(set = 1, binding = 3) uniform texture2D Normal;

// TODO: Make these dynamically adjustable
const float radius = 1.2;
const float bias = 0.05;
const int num_samples = 16;

vec3 randomSample(inout uint seed) {
    const float r1 = RandomFloat(seed);
    const float r2 = RandomFloat(seed);

    const float r = sqrt(1.0 - r1 * r1);
    const float phi = 2.0 * 3.14159265358979323846f * r2;
    return normalize(vec3(cos(phi) * r, sin(phi) * r, r1));
}

void main()
{
    const ivec2 image_size = imageSize(SSAOTexture).xy;
    const ivec2 pixel = ivec2(gl_GlobalInvocationID.x % image_size.x, gl_GlobalInvocationID.x / image_size.x);
    if (pixel.x >= image_size.x || pixel.y >= image_size.y) {
        return;
    }

    uint seed = WangHash((pixel.x + pixel.y * image_size.x) * 16789 * 1791);
    const vec2 UV = vec2(pixel) / textureSize(sampler2D(ScreenSpace, Sampler), 0).xy;

    // Inspired by https://www.trentreed.net/blog/screen-space-ambient-occlusion/
    const vec3 fragPos = texture(sampler2D(ScreenSpace, Sampler), UV).xyz;

    // iterate over the sample kernel and calculate occlusion factor
    float occlusion = 0.0;
    for (int i = 0; i < num_samples; ++i)
    {
        const vec3 S = fragPos + randomSample(seed) * radius;

        // project sample position (to sample texture) (to get position on screen/texture)
        vec4 offset = vec4(S, 1.0);
        offset = Proj * offset;// from view to clip-space
        offset.xy /= offset.w;// perspective divide

        const float sampleDepth = texture(sampler2D(ScreenSpace, Sampler), offset.xy * vec2(0.5, -0.5) + 0.5).z;
        const float rangeCheck = smoothstep(0.0, 1.0, radius / abs(fragPos.z - sampleDepth));
        if (sampleDepth >= S.z + bias) {
            occlusion += 1.0 * rangeCheck;
        }
    }

    occlusion = 1.0 - (occlusion * (1.0 / num_samples));
    //    occlusion = occlusion * occlusion;
    imageStore(SSAOTexture, pixel, vec4(occlusion));
}